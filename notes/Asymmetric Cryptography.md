---
layout: page
permalink: notes/asymmetric-cryptography
tags: en
title: Asymmetric Cryptography
---

## Public Key Encryption

We now define a formally what is a  public key encryption

### Formal definition of Public Key Encryption
We define a 3-tuple formed as follows: $$(G, E, D)$$ where 
- $$G$$ is the generator for the private and public keys, from now on identified as $$(pk, sk)$$ (public key and secret key)
- $$E$$ the encryption algorithm, that takes the $$pk$$ and the message in input
- $$D$$ the decryption algorithm, that takes the $$sk$$ and the cyphertext in input.

Now is this definition useful? i don't think so! We can't create theorems for it, too general I suppose. Is it clear? yes! I think this is the usefulness of maths in many occasions, it delivers some complex information in a concise and understandable manner.

### Some observations about Public Key Encryption

#### Semantic security to Eavesdropping
This is the same as explained in [Advantage security](/notes/otp-and-stream-ciphers#security-with-advantage) explained in a previous section.
We defined the advantage as the ability of the attacker to distinguish the original message. This is still exactly the same, see that section. (the only difference is that here we use public key encryption)
<img src="/images/notes/Asymmetric Cryptography-20240402230103858.webp" alt="Asymmetric Cryptography-20240402230103858">
#### Resistance against Many Time Pads
We know that in the symmetric context in [Block Ciphers](/notes/block-ciphers) and [OTP and Stream Ciphers](/notes/otp-and-stream-ciphers), it is often not secure to use the symmetric key to many times. (This is clearly true when we are talking about the OTP cipher).

But in the context of Asymmetric keys this notion is *not true* as the key is public, this key can be used as many times as the attacker wants. So he can reuse the key, while the cipher should still remain secure!


## Trapdoor functions

### Definition of Trapdoor functions
This is a triple $$G, F, F^{-1}$$ very similar to the previous one (indeed it's kinda the same definition) The only difference is that $$F^{-1}$$ is the inverse.

#### Secure Trapdoor Functions ðŸŸ¨-
NOTE: direct use of $$F$$ and $$F^{-1}$$ to encrypt and decrypt using the created keys is not secure.

A trapdoor is secure if it's difficult to invert without the knowledge of $$sk$$.
See image
<img src="/images/notes/Asymmetric Cryptography-20240319111432568.jpg" alt="Asymmetric Cryptography-20240319111432568">

#### Creating a PKE from Trapdoors ðŸŸ¨--

<img src="/images/notes/Asymmetric Cryptography-20240319101427775.jpg" alt="Asymmetric Cryptography-20240319101427775">

### One Way Hash Algorithms
These are different from [Hash tables](/notes/tabelle-di-hash) which is a datastructure!

We can see that One-Way hashes are a trapdors with $$pk = sk$$.
Usually it is a function that takes a input of arbitrary length and outputs a limited string with some important properties.

#### Properties of One Way Hash Algorithms ðŸŸ©-
1. Easy to Evaluate:
	The hashing algorithm should be fast
2. Hard to Reverse:
	There is no feasible algorithm to "reverse" a hash value,
	That is, given any hash value $$h$$, it is computationally infeasible to find any document $$m$$ such that $$H(m) = h$$.
3. Hard to find Collisions:
	There is no feasible algorithm to find two or more input documents which are hashed into the same condensed output,
	That is, it is computationally infeasible to find any two documents $$m_{2}, m_{2}$$ such that $$H(m_{1})= H(m_{2})$$.
	    Although, theoretical requirements say there are many many collisions. But the difficult thing is tampering, that is add some strings, make some modifications of the original messages such that that hash matches with others.
1. A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value

## RSA Cryptosystem

### Definition of the trapdoor function
We define $$F: \mathbb{Z}^{*}_{\mathbb{N}} \to \mathbb{Z}^{*}_{\mathbb{N}}$$ as $$RSA(x) = x^{e}$$  where $$e$$ is the public key generated by the key generation function and $$N = pq$$ is the private key, where $$p, q$$ are big primes.

Then using [Euler's theorem](/notes/teorema-di-lagrange#teorema-di-eulero) we know how to compute $$d$$ such that $$x^{ed} =x \mod N$$ where $$d$$ is the inverse modulo that, this is how we decrypt.
How do we compute $$d$$? We use euler's theorem, and find this $$e\cdot d = 1 \mod \varphi(N)$$. and $$e$$ should be invertible with it is coprime with $$N$$ (true by construction).

### Security Analysis of RSA
NOTE: normal RSA as defined above is not secure.

#### Simple semantic security attack on RSA
I can get back to the original message with a small effort. The percentage of success is high enough not to be negligible.

<img src="/images/notes/Asymmetric Cryptography-20240319114920695.jpg" alt="Asymmetric Cryptography-20240319114920695">
#### Advantage notation for RSA
We want the possibility to compute the $$e$$ root modulo $$N$$ to be small, and using the notion of advantage developed in [OTP and Stream Ciphers#Security with advantage](/notes/otp-and-stream-ciphers#security-with-advantage) we write

$$
Pr\left[ A(N, e, y) = y ^{1/e} \right] < \varepsilon
$$

Where $$\varepsilon$$ is very small, **negligible** so to say, and $$A$$ is the $$F$$ trapdoor function used for RSA.

#### Wiener's attack (non fatto)
This section is not useful for the exam, just for personal knowledge!
If the private keys have certain properties, there exists some attacks, one example is the Wiener's attack
<img src="/images/notes/Asymmetric Cryptography-20240321101500213.webp" alt="Asymmetric Cryptography-20240321101500213">
#### Low public exponent attack ðŸŸ©
Usually minimum that is used is 3. If 2 then the inverse is not guaranteed because $$mcd(2, (p - 1) ( q - 1)) \neq 1$$ .

This is a stupid attack. Then the exponent is small enough, and it is not able to wrap the module, then the root is quite easy to achieve.
This is why the **recommended value** is big, usually = $$2^{16} + 1 = 65537$$.

Usually this is used to **speed up** encryption, it easier to compute. Other variants, like *Elgamal* have almost same time to encrypt and decrypt.

#### Comparison with symmetric keys

| AES key size | RSA modulus size |
| ------------ | ---------------- |
| 80 bit       | 1024 bits        |
| 128 bits     | 3072 bits        |
| 256 bits     | 15360 bits       |
We observe that RSA needs a lot more bits to ensure the same security!

### Side channel attacks
these attacks do not directly attack the cipher, but the infrastructure or computing that it uses.
#### Timing attack
Can leak $$d$$ secret key by tracking the compute time. (Kocher 1997)

#### Power attack
Can leak $$d$$ by tracking power usage. (Kocher 1999)
#### Faults attack
Errors can leak $$d$$ somehow (don't know!) (BDL 1997).
<img src="/images/notes/Asymmetric Cryptography-20240321110527763.webp" width="481" alt="Asymmetric Cryptography-20240321110527763">
In questa fase viene leakato il valore di $$p$$ che permette di ricostruire la chiave privata.
#### Key generation
<img src="/images/notes/Asymmetric Cryptography-20240321110517713.webp" alt="Asymmetric Cryptography-20240321110517713">
### Variations
#### Elgamal
Find $$g$$ and $$p$$ such that $$g$$ is primitive root modulo $$p$$. Some strange properties here.
This means that $$\forall a, \exists k : g^{k} = a  \mod p$$. This is inspired from the [Key Exchange protocols#Diffie-Hellman Protocol](/notes/key-exchange-protocols#diffie-hellman-protocol).
Then the first person chooses $$a \in \left[ 0, p - 2 \right]$$ randomly and calculates $$A = g^{a} \mod p$$ and the tuple $$(p , g, A)$$ is then considered as the public key.
When someone wants to send a message $$m$$, he/she does this:
Chooses a $$b$$ in exact manner as before.
Computes $$c = A^{b}m \mod p$$ and sends this c.
The receiver computes the inverse for this exponent, and then inverts $$g^{b} \mod p$$ to calculate the original message $$m$$.

Notes on security -> **Discrete log problem**.
Efficiency -> No, ciphertext needs that public key to be sent, which is usually long and expensive to calculate compared to AES.
#### Rabin cryptosystem
we create $$p,q$$ such that their modulus $$4$$ is 3, probably for some nice properties I don't know of...
The advantage is that his security is prooved.
Calculate $$n = pq$$ and this is the public key.
When somebody wants to communicate, he just calculates


$$
c = m^{2} \mod  n
$$

And sends this, probably with this setting the properties of $$p, q$$ make that invertible, but not sure why.
<img src="/images/notes/Asymmetric Cryptography-20240402233238657.webp" alt="Asymmetric Cryptography-20240402233238657">
If you are curious try to understand why is this valid.

## Digital signatures
The main idea is to cipher with the private key, so that it can be verifiable using the public.
It was cited in [Sicurezza delle reti](/notes/sicurezza-delle-reti) times before.
To overcome the burden to encrypt the whole text, usually only an hash is encrypted.


### Advantages of Digital signatures
- **Unforgeable**
- **Un-deniable** by the signatory (if you have signed it, it was you!)
- **Universally verifiable** (everybody can verify it)
- Every doc's signature is **different**.