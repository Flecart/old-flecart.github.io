---
layout: page
permalink: notes/asymmetric-cryptography
tags: italian
title: Asymmetric Cryptography
---

## Public Key Encryption

We now define a formally what is a  public key encryption

### Formal definition of Public Key Encryption
We define a 3-tuple formed as follows: $$(G, E, D)$$ where 
- $$G$$ is the generator for the private and public keys, from now on identified as $$(pk, sk)$$ (public key and secret key)
- $$E$$ the encryption algorithm, that takes the $$pk$$ and the message in input
- $$D$$ the decryption algorithm, that takes the $$sk$$ and the cyphertext in input.

Now is this definition useful? i don't think so! We can't create theorems for it, too general I suppose. Is it clear? yes! I think this is the usefulness of maths in many occasions, it delivers some complex information in a concise and understandable manner.

### Some observations about Public Key Encryption

#### Semantic security to Eavesdropping
This is the same as explained in [Advantage security](/notes/otp-and-stream-ciphers#security-with-advantage) explained in a previous section.
We defined the advantage as the ability of the attacker to distinguish the original message. This is still exactly the same, see that section. (the only difference is that here we use public key encryption)

#### Resistance against Many Time Pads
We know that in the symmetric context in [Block Ciphers](/notes/block-ciphers) and [OTP and Stream Ciphers](/notes/otp-and-stream-ciphers), it is often not secure to use the symmetric key to many times. (This is clearly true when we are talking about the OTP cipher).

But in the context of Asymmetric keys this notion is *not true* as the key is public, this key can be used as many times as the attacker wants. So he can reuse the key, while the cipher should still remain secure!


## Trapdoor functions

### Definition of Trapdoor functions
This is a triple $$G, F, F^{-1}$$ very similar to the previous one (indeed it's kinda the same definition) The only difference is that $$F^{-1}$$ is the inverse.

#### Secure Trapdoor Functions
NOTE: direct use of $$F$$ and $$F^{-1}$$ to encrypt and decrypt using the created keys is not secure.

A trapdoor is secure if it's difficult to invert without the knowledge of $$sk$$.
See image
<img src="/images/notes/Asymmetric Cryptography-20240319111432568.jpg" alt="Asymmetric Cryptography-20240319111432568">

#### Creating a PKE from Trapdoors

<img src="/images/notes/Asymmetric Cryptography-20240319101427775.jpg" alt="Asymmetric Cryptography-20240319101427775">

### One Way Hash Algorithms
These are different from [Hash tables](/notes/tabelle-di-hash) which is a datastructure!

We can see that One-Way hashes are a trapdors with $$pk = sk$$.
Usually it is a function that takes a input of arbitrary length and outputs a limited string with some important properties.

#### Properties of One Way Hash Algorithms
1. Easy to Evaluate:
	The hashing algorithm should be fast
2. Hard to Reverse:
	There is no feasible algorithm to "reverse" a hash value,
	That is, given any hash value $$h$$, it is computationally infeasible to find any document $$m$$ such that $$H(m) = h$$.
3. Hard to find Collisions:
	There is no feasible algorithm to find two or more input documents which are hashed into the same condensed output,
	That is, it is computationally infeasible to find any two documents $$m_{2}, m_{2}$$ such that $$H(m_{1})= H(m_{2})$$.
	    Although, theoretical requirements say there are many many collisions. But the difficult thing is tampering, that is add some strings, make some modifications of the original messages such that that hash matches with others.
1. A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value

## RSA Cryptosystem

### Definition of the trapdoor function
We define $$F: \mathbb{Z}^{*}_{\mathbb{N}} \to \mathbb{Z}^{*}_{\mathbb{N}}$$ as $$RSA(x) = x^{e}$$  where $$e$$ is the public key generated by the key generation function and $$N = pq$$ is the private key, where $$p, q$$ are big primes.

Then using [Euler's theorem](/notes/teorema-di-lagrange#teorema-di-eulero) we know how to compute $$d$$ such that $$x^{ed} =x \mod N$$ where $$d$$ is the inverse modulo that, this is how we decrypt.
How do we compute $$d$$? We use euler's theorem, and find this $$e\cdot d = 1 \mod \varphi(N)$$. and $$e$$ should be invertible with it is coprime with $$N$$ (true by construction).

### Security Analysis of RSA
NOTE: normal RSA as defined above is not secure.

#### Simple semantic security attack on RSA
I can get back to the original message with a small effort. The percentage of success is high enough not to be negligible.

<img src="/images/notes/Asymmetric Cryptography-20240319114920695.jpg" alt="Asymmetric Cryptography-20240319114920695">